/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package compilador;

import java.awt.Color;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;

import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.table.DefaultTableModel;

//creacion de archivo txt

/**
 *
 * @author kreed
 */
public class Interfaz extends javax.swing.JFrame {

    //Variables
    private DefaultTableModel modelo;
    private String rutaCompleta = "";
    FileWriter archivo = null;
    PrintWriter escritor = null; 

    //ZONA DE LAS EXPRESIONES REGULARES PARA VALIDAR
    private String regexI = ">[A-Z0-9Â¬@]*"; //Expresion regular para identificadores
    private String regexT = "!(cad|flo|ent)";//Expresion regular para ver que tipo de variable es
    private String regexA = "="; //Expresion regulara para asignacion
    private String regexS = "[(),{};]"; //Expresion regular para identificar los separadores
    private String regexE = "(-|)4[0-9]*4"; //Expresion regular para determinar si es un numero entero
    private String regexF = "(-|)[0-9]+.4[0-9]*4"; //Expresion regular para determinar si es un numero Flotante o con decimal
    private String regexC = "\"[A-Za-z0-9.!@]+\""; //Expresion regular para saber si es una cadena
    private String regexO = "[-+*/()]"; //Expresion regular para saber si es un operador

    //Zona de arrays para guardar los valores
    ArrayList<String> tipo = new ArrayList<>();
    ArrayList<String> Identificador = new ArrayList<>();
    
    //arrayList para guardar las cadenas de texto
    ArrayList<String> CadenaOptimizados = new ArrayList<>();

    //obtiene informacion de las variables 
    HashMap<String, String> Global = new HashMap<>();

    //guarda informacion de las funciones y la linea de comienzo y de terminado
    HashMap<String, String> funcionInf = new HashMap<>();

    ArrayList<String> asignacion = new ArrayList<>();
    ArrayList<String> separador = new ArrayList<>();
    ArrayList<String> enteros = new ArrayList<>();
    ArrayList<String> cadenas = new ArrayList<>();
    ArrayList<String> flotantes = new ArrayList<>();
    ArrayList<String> operador = new ArrayList<>();
    ArrayList<String> operadorAnterior = new ArrayList<>();
    
    //guarda el nombre de las funciones
    ArrayList<String> nombreFuncio = new ArrayList<>();

    public Interfaz() {
        initComponents();
        this.setLocationRelativeTo(null);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        Panel = new javax.swing.JPanel();
        btnArchivo = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        txtAreaCodigo = new javax.swing.JTextArea();
        btnAnalizar = new javax.swing.JButton();
        jScrollPane2 = new javax.swing.JScrollPane();
        tblSimbolos = new javax.swing.JTable();
        lblTitulo = new javax.swing.JLabel();
        lblTitulo2 = new javax.swing.JLabel();
        lblTituloProyecto = new javax.swing.JLabel();
        jScrollPane3 = new javax.swing.JScrollPane();
        tblCodInter = new javax.swing.JTable();
        jLabel1 = new javax.swing.JLabel();
        lblOriginal = new javax.swing.JLabel();
        jScrollPane5 = new javax.swing.JScrollPane();
        txtAreaOptmizado = new javax.swing.JTextArea();
        lblOptimizado = new javax.swing.JLabel();
        btnBuscar2 = new javax.swing.JButton();
        btnAnalizarOptimizado = new javax.swing.JButton();
        lblTituloTablaEnsamblador = new javax.swing.JLabel();
        jScrollPane7 = new javax.swing.JScrollPane();
        txtAreaEnsamblador = new javax.swing.JTextArea();
        jScrollPane4 = new javax.swing.JScrollPane();
        tblErrores = new javax.swing.JTable();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Analizador lexico y sintactico");

        btnArchivo.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        btnArchivo.setText("Buscar Archivo");
        btnArchivo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnArchivoActionPerformed(evt);
            }
        });

        txtAreaCodigo.setColumns(20);
        txtAreaCodigo.setFont(new java.awt.Font("Monospaced", 0, 18)); // NOI18N
        txtAreaCodigo.setRows(5);
        jScrollPane1.setViewportView(txtAreaCodigo);

        btnAnalizar.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        btnAnalizar.setText("Optimizar");
        btnAnalizar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnAnalizarActionPerformed(evt);
            }
        });

        tblSimbolos.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        tblSimbolos.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Token", "Lexema", "Tipo"
            }
        ));
        jScrollPane2.setViewportView(tblSimbolos);

        lblTitulo.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        lblTitulo.setText("Tabla de simbolos");
        lblTitulo.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));

        lblTitulo2.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        lblTitulo2.setText("Tabla de Errores Semanticos");

        lblTituloProyecto.setFont(new java.awt.Font("Tahoma", 0, 48)); // NOI18N
        lblTituloProyecto.setText("Equipo 4");

        tblCodInter.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        tblCodInter.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "", "Dato Objeto", "Dato Fuente", "Operador"
            }
        ));
        jScrollPane3.setViewportView(tblCodInter);

        jLabel1.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        jLabel1.setText(" [ Codigo Intermedio ]");

        lblOriginal.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        lblOriginal.setText("Codigo Original");
        lblOriginal.setToolTipText("");

        txtAreaOptmizado.setColumns(20);
        txtAreaOptmizado.setFont(new java.awt.Font("Monospaced", 0, 18)); // NOI18N
        txtAreaOptmizado.setRows(5);
        jScrollPane5.setViewportView(txtAreaOptmizado);

        lblOptimizado.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        lblOptimizado.setText("Codigo optimizado");

        btnBuscar2.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        btnBuscar2.setText("Buscar Archivo");
        btnBuscar2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnBuscar2ActionPerformed(evt);
            }
        });

        btnAnalizarOptimizado.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        btnAnalizarOptimizado.setText("Analizar");
        btnAnalizarOptimizado.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnAnalizarOptimizadoActionPerformed(evt);
            }
        });

        lblTituloTablaEnsamblador.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        lblTituloTablaEnsamblador.setText(" [ Codigo Ensamblador ] ");

        txtAreaEnsamblador.setColumns(20);
        txtAreaEnsamblador.setFont(new java.awt.Font("Monospaced", 0, 24)); // NOI18N
        txtAreaEnsamblador.setRows(5);
        jScrollPane7.setViewportView(txtAreaEnsamblador);

        tblErrores.setAutoCreateRowSorter(true);
        tblErrores.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        tblErrores.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Token", "Lexema", "Linea", "Descripcion"
            }
        ));
        tblErrores.setRowHeight(18);
        tblErrores.setRowMargin(2);
        jScrollPane4.setViewportView(tblErrores);

        javax.swing.GroupLayout PanelLayout = new javax.swing.GroupLayout(Panel);
        Panel.setLayout(PanelLayout);
        PanelLayout.setHorizontalGroup(
            PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(PanelLayout.createSequentialGroup()
                .addGap(30, 30, 30)
                .addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(PanelLayout.createSequentialGroup()
                        .addComponent(btnArchivo)
                        .addGap(79, 79, 79)
                        .addComponent(lblOriginal)
                        .addGap(111, 111, 111)
                        .addComponent(btnAnalizar)
                        .addGap(295, 295, 295)
                        .addComponent(lblTitulo)
                        .addGap(407, 407, 407)
                        .addComponent(lblTitulo2)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(PanelLayout.createSequentialGroup()
                        .addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addGroup(PanelLayout.createSequentialGroup()
                                .addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                    .addGroup(PanelLayout.createSequentialGroup()
                                        .addComponent(btnBuscar2)
                                        .addGap(63, 63, 63)
                                        .addComponent(lblOptimizado, javax.swing.GroupLayout.PREFERRED_SIZE, 186, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                        .addComponent(btnAnalizarOptimizado))
                                    .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, 601, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(PanelLayout.createSequentialGroup()
                                        .addGap(26, 26, 26)
                                        .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 621, Short.MAX_VALUE))
                                    .addGroup(PanelLayout.createSequentialGroup()
                                        .addGap(280, 280, 280)
                                        .addComponent(jLabel1)
                                        .addGap(0, 0, Short.MAX_VALUE))))
                            .addGroup(PanelLayout.createSequentialGroup()
                                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 609, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(18, 18, 18)
                                .addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(lblTituloProyecto)
                                    .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 604, javax.swing.GroupLayout.PREFERRED_SIZE))))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, PanelLayout.createSequentialGroup()
                                .addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                    .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 581, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jScrollPane7, javax.swing.GroupLayout.PREFERRED_SIZE, 564, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(420, 420, 420))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, PanelLayout.createSequentialGroup()
                                .addComponent(lblTituloTablaEnsamblador)
                                .addGap(581, 581, 581))))))
        );
        PanelLayout.setVerticalGroup(
            PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(PanelLayout.createSequentialGroup()
                .addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(PanelLayout.createSequentialGroup()
                        .addGap(47, 47, 47)
                        .addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(btnArchivo, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lblOriginal)
                            .addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(btnAnalizar, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(lblTitulo)
                                .addComponent(lblTitulo2, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE))))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, PanelLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(lblTituloProyecto, javax.swing.GroupLayout.PREFERRED_SIZE, 69, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(18, 18, 18)
                .addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(PanelLayout.createSequentialGroup()
                        .addGap(0, 1, Short.MAX_VALUE)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 420, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(PanelLayout.createSequentialGroup()
                                .addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                    .addComponent(btnAnalizarOptimizado)
                                    .addComponent(btnBuscar2)
                                    .addComponent(lblOptimizado, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(13, 13, 13))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, PanelLayout.createSequentialGroup()
                                .addComponent(lblTituloTablaEnsamblador)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED))))
                    .addGroup(PanelLayout.createSequentialGroup()
                        .addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                            .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                        .addGap(80, 80, 80)))
                .addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(PanelLayout.createSequentialGroup()
                        .addComponent(jScrollPane5, javax.swing.GroupLayout.PREFERRED_SIZE, 450, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, PanelLayout.createSequentialGroup()
                        .addGroup(PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jScrollPane7)
                            .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 433, Short.MAX_VALUE))
                        .addGap(124, 124, 124))))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(Panel, javax.swing.GroupLayout.PREFERRED_SIZE, 1892, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(Panel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(495, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /* BOTON PARA OBTENER MOSTRAR EL CONTENIDO DE UNA ARCHIVO */
    private void btnArchivoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnArchivoActionPerformed
        if (txtAreaCodigo.getText().isEmpty()) {
            JFileChooser chooser = new JFileChooser();
            chooser.showOpenDialog(null);
            File arq = new File(chooser.getSelectedFile().getAbsolutePath());
            rutaCompleta = chooser.getSelectedFile().getAbsolutePath();
            try {
                String ST = new String(Files.readAllBytes(arq.toPath()));
                txtAreaCodigo.setText(ST);
            } catch (IOException ex) {
                Logger.getLogger(Interfaz.class.getName()).log(Level.SEVERE, null, ex);
            }
        } else {
            //txtAnalizador.setText("");
        }
    }//GEN-LAST:event_btnArchivoActionPerformed

    /*BOTON PARA ANALIZAR EL ARCHIVO Y COLOCAR LAS COINCIDENCIAS EN UNA TABLA*/
    private void btnAnalizarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnAnalizarActionPerformed
        try {
            factorizacion(rutaCompleta);
        } catch (IOException ex) {
            Logger.getLogger(Interfaz.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_btnAnalizarActionPerformed

    private void btnAnalizarOptimizadoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnAnalizarOptimizadoActionPerformed
        // TODO add your handling code here:
        analizarHechoPorMi(rutaCompleta);
        analizarAsignaciones(rutaCompleta);
        generarTriplo(rutaCompleta);
        generadorEnsamblador();
    }//GEN-LAST:event_btnAnalizarOptimizadoActionPerformed

    private void btnBuscar2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnBuscar2ActionPerformed
        // TODO add your handling code here:
        try {
            JFileChooser chooser = new JFileChooser();
            chooser.showOpenDialog(null);
            File arq = new File(chooser.getSelectedFile().getAbsolutePath());
            rutaCompleta = chooser.getSelectedFile().getAbsolutePath();
            String ST = new String(Files.readAllBytes(arq.toPath()));
            txtAreaOptmizado.setText(ST);
        } catch (IOException ex) {
            Logger.getLogger(Interfaz.class.getName()).log(Level.SEVERE, null, ex);
            System.err.println("OCURRIO UN ERROR");
        }
    }//GEN-LAST:event_btnBuscar2ActionPerformed

    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Interfaz.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Interfaz.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Interfaz.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Interfaz.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Interfaz().setVisible(true);
            }
        });
    }

    public File rutaArchivo() {
        JFileChooser chooser = new JFileChooser();
        chooser.showOpenDialog(null);
        File archivo = chooser.getSelectedFile();
        return archivo;
    }

    public String leerArchivo(String ruta) {
        String bfRead, temp = "";
        try {
            BufferedReader bf = new BufferedReader(new FileReader(ruta));
            while ((bfRead = bf.readLine()) != null) {
                temp = temp + bfRead + "\n";
            }
        } catch (Exception e) {
            System.out.println("e --> " + e.getMessage());
            System.err.println("Error al abrir el archivo");
        }
        return temp;
    }

    public String leerTxt(String ruta) {
        String bfRead, temp = "";
        try {
            BufferedReader bf = new BufferedReader(new FileReader(ruta));
            while ((bfRead = bf.readLine()) != null) {
                temp = temp + bfRead;
            }
        } catch (Exception e) {
            System.out.println("e --> " + e.getMessage());
            System.err.println("Error al abrir el archivo");
        }
        return temp;
    }
    
    //ANALIZADOR Y VERIFICADOR PARA LA TABLA DE ERRORES Y TABLA DE SIMBOLOS ----
    public void analizarHechoPorMi(String ruta) {

        modelo = (DefaultTableModel) tblSimbolos.getModel();
        DefaultTableModel modelo2 = (DefaultTableModel) tblErrores.getModel();

        //divimos la cadena por lineas cuando el spli encuetre un ;
        String cadena[] = leerTxt(ruta).split(";");

        //ahora cada linea sera divida en partes y asi para poder encontrar el valor de los identificadores
        try {
            for (int j = 0; j < cadena.length; j++) {
                String interno[] = cadena[j].split(" ");
                for (int i = 0; i < interno.length; i++) {

                    //verificamos si es un tipo de valor
                    if (interno[i].matches(regexT)) {
                        if (tipo.isEmpty()) {
                            tipo.add(interno[i]);
                            modelo.addRow(new Object[]{"-", interno[i]});
                        } else if (tipo.contains(interno[i]) != true) {
                            tipo.add(interno[i]);
                            modelo.addRow(new Object[]{"-", interno[i]});
                        }
                    }

                    //obtenemos el valor del identificador y su valor tambien                    
                    if (i == 0 && interno[i].matches(regexT)) {
                        for (int k = 1; k < interno.length; k++) {

                            if (interno[k].matches(regexA) && interno[k + 1].matches(regexI)) {
                                //System.out.println(interno[k] + " : " + interno[k + 1]);
                                continue;
                            } else if (interno[k].matches(regexI) && interno[k - 1].matches(regexA)) {
                                //System.out.println(interno[k] + " : " + interno[k - 1]);
                                continue;
                            } else if (interno[k].equals("(") && interno[k - 1].matches(regexI)) {
                                for (int h = k + 1; h < interno.length; h++) {
                                    if (interno[h].matches(regexT) && interno[h + 1].matches(regexI)) {
                                        modelo.addRow(new Object[]{"-", interno[h + 1], interno[h]});
                                        Global.put(interno[h + 1], interno[h]);
                                    } else if (interno[h].matches(regexT) && !interno[h + 1].matches(regexI)) {
                                        modelo2.addRow(new Object[]{"ERSem", " ", j + 1, interno[h] + " no cuenta con un identificador"});
                                    }

                                }
                                break;
                            } else {
                                if (interno[k].matches(regexI)) {
                                    if (Identificador.isEmpty()) {
                                        Identificador.add(interno[k]);
                                        modelo.addRow(new Object[]{"-", interno[k], interno[0]});
                                        Global.put(interno[k], interno[0]);
                                    } else if (Identificador.contains(interno[k]) != true) {
                                        Identificador.add(interno[k]);
                                        modelo.addRow(new Object[]{"-", interno[k], interno[0]});
                                        Global.put(interno[k], interno[0]);
                                    }
                                }
                            }

                        }
                    }

                    //verificamos asignaciones
                    if (interno[i].matches(regexA)) {

                        if (asignacion.isEmpty()) {
                            asignacion.add(interno[i]);
                            modelo.addRow(new Object[]{"-", interno[i]});
                        } else if (asignacion.contains(interno[i]) != true) {
                            asignacion.add(interno[i]);
                            modelo.addRow(new Object[]{"-", interno[i]});
                        }
                    }

                    //verificamos si hay un separador
                    if (interno[i].matches(regexS)) {

                        if (separador.isEmpty()) {
                            separador.add(interno[i]);
                            modelo.addRow(new Object[]{"-", interno[i]});
                        } else if (separador.contains(interno[i]) != true) {
                            separador.add(interno[i]);
                            modelo.addRow(new Object[]{"-", interno[i]});
                        }
                    }

                    //verificamos si es una cadena
                    if (interno[i].matches(regexC)) {

                        if (cadenas.isEmpty()) {
                            cadenas.add(interno[i]);
                            modelo.addRow(new Object[]{"-", interno[i], "!cad"});
                            Global.put(interno[i], "!cad");
                        } else if (cadenas.contains(interno[i]) != true) {
                            cadenas.add(interno[i]);
                            modelo.addRow(new Object[]{"-", interno[i], "!cad"});
                            Global.put(interno[i], "!cad");
                        }
                    }

                    //verificamos si hay un Entero
                    if (interno[i].matches(regexE)) {

                        if (enteros.isEmpty()) {
                            enteros.add(interno[i]);
                            modelo.addRow(new Object[]{"-", interno[i], "!ent"});
                            Global.put(interno[i], "!ent");
                            System.out.println(enteros.contains(interno[i]));
                        } else if (enteros.contains(interno[i]) != true) {
                            enteros.add(interno[i]);
                            modelo.addRow(new Object[]{"-", interno[i], "!ent"});
                            Global.put(interno[i], "!ent");
                        }
                    }

                    //verificamos si hay un Flotante
                    if (interno[i].matches(regexF)) {

                        if (flotantes.isEmpty()) {
                            flotantes.add(interno[i]);
                            modelo.addRow(new Object[]{"-", interno[i], "!flo"});
                            Global.put(interno[i], "!flo");
                        } else if (enteros.contains(interno[i]) != true) {
                            flotantes.add(interno[i]);
                            modelo.addRow(new Object[]{"-", interno[i], "!flo"});
                            Global.put(interno[i], "!flo");
                        }
                    }

                    //verificamos si es un operador
                    if (interno[i].matches(regexO)) {

                        if (operador.isEmpty()) {
                            operador.add(interno[i]);
                            modelo.addRow(new Object[]{"-", interno[i]});
                        } else if (operador.contains(interno[i]) != true) {
                            operador.add(interno[i]);
                            modelo.addRow(new Object[]{"-", interno[i]});
                        }
                    }

                    //verificamos si es un return
                    if (interno[i].equals("return")) {

                        String lexema = interno[i + 1];
                        if (Global.containsKey(lexema)) {
                            modelo.addRow(new Object[]{"-", interno[i], Global.get(lexema)});
                            Global.put(interno[i], Global.get(lexema));
                        } else {
                            modelo2.addRow(new Object[]{"ERSem", interno[i], "Linea: " + j, "Retorno con variable Indefinida"});
                        }
                    }

                }
            }

        } catch (IndexOutOfBoundsException e) {
            e.printStackTrace();
        }

    }

    public void analizarAsignaciones(String ruta) {

        DefaultTableModel modelo2 = (DefaultTableModel) tblErrores.getModel();
        int contador = 0;

        String cadena[] = leerTxt(ruta).split(";");
        try {
            for (int j = 0; j < cadena.length; j++) {
                String linea[] = cadena[j].split(" ");

                for (int i = 0; i < linea.length; i++) {

                    if (linea[i].matches(regexA)) {
                        String valor1 = linea[i - 1];
                        String valor2 = linea[i + 1];
                        //System.out.println(valor1 + " " + linea[i] + " " + valor2);

                        if (Global.containsKey(valor1) && Global.containsKey(valor2)) {

                            //System.out.println("Entro aqui porque los dos identificadores si existen ");
                            //entero = entero | real = real | cadena = cadena
                            if (Global.get(valor1).equals(Global.get(valor2))) {
                                //System.out.println("Entro aqui en obtener valor del identificador");
                            } else if (Global.get(valor1).equals("!flo") && Global.get(valor2).equals("!ent")) {
                                //System.out.println(Global.get(valor1) + " <--- " + Global.get(valor2));
                            } else {
                                contador++;
                                modelo2.addRow(new Object[]{"ERSem" + contador, valor2, "linea: " + j, "Incompatibilidad de asignacion\n " + Global.get(valor1) + " <--- " + Global.get(valor2)});
                            }

                        } else {
                            contador++;
                            if (!Global.containsKey(valor1)) {
                                modelo2.addRow(new Object[]{"ERSem" + contador, valor1, "linea: " + j, "Identificador Indefinido"});
                            } else if (!Global.containsKey(valor2)) {
                                modelo2.addRow(new Object[]{"ERSem" + contador, valor2, "linea: " + j, "Identificador Indefinido"});
                            }
                        }

                    }

                    if (linea[i].matches(regexO) && !linea[i].matches(regexS)) {
                        String valor1 = linea[i - 1];
                        String valor2 = linea[i + 1];

                        if (Global.containsKey(valor1) && Global.containsKey(valor2)) {

                            //System.out.println("Entro aqui porque los dos identificadores si existen ");
                            //cadena = cadena
                            if (!Global.get(valor1).equals("!cad") && !Global.get(valor2).equals("!cad")) {
                                //System.out.println("Entro aqui en obtener valor del identificador");
                            } else {
                                contador++;
                                modelo2.addRow(new Object[]{"ERSem" + contador, linea[i], "linea: " + j, "Error operacion aritmetica entre Cadenas"});
                            }

                        } else {
                            contador++;
                            if (!Global.containsKey(valor1)) {
                                modelo2.addRow(new Object[]{"ERSem" + contador, valor1, "linea: " + j, "Identificador Indefinido"});
                            } else if (!Global.containsKey(valor2)) {
                                modelo2.addRow(new Object[]{"ERSem" + contador, valor2, "linea: " + j, "Identificador Indefinido"});
                            }
                        }

                    }

                    if (linea[i].equals("(") && linea[i - 1].matches(regexI)) {
                        String NombreOperador = linea[i - 1];
                        int totalArgumentos = 0;

                        ArrayList<String> tipoOperador = new ArrayList<>();

                        for (int n = i; n < linea.length; n++) {
                            if (linea[n].matches(regexT) && linea[n + 1].matches(regexI)) {
                                tipoOperador.add(Global.get(linea[n + 1]));
                                totalArgumentos++;
                            }
                        }

                        if (Global.get("return").equals("!cad")) {
                            contador++;
                            modelo2.addRow(new Object[]{"ERSem" + contador, "return", "linea: " + j, "Error en valor de retorno " + Global.get(NombreOperador) + " <--- " + Global.get("return")});
                        }
                        int nArgs = 0;
                        for (int l = j + 1; l < cadena.length; l++) {
                            String text[] = cadena[l].split(" ");
                            for (int m = 0; m < text.length; m++) {
                                if (text[m].equals(NombreOperador)) {
                                    System.out.println(text[m]);
                                    for (int v = m + 1; v < text.length; v++) {
                                        if (Global.containsKey(text[v])) {
                                            int index = 0;
                                            System.out.println(tipoOperador.get(index) + text[v]);
                                            index++;
                                            if (tipoOperador.contains(Global.get(text[v])) != true) {
                                                contador++;
                                                modelo2.addRow(new Object[]{"ERSem" + contador, text[v], "linea: " + l, "Error en asignacion de parametros "});
                                                nArgs++;
                                            }
                                        }
                                    }

                                }
                            }
                        }

                    }

                }

            }
        } catch (IndexOutOfBoundsException ex) {

        }
    }
    
    //GENERADOR DEL TRIPO AQUI ----------------
    public void generarTriplo(String ruta) {
        DefaultTableModel tabla3 = (DefaultTableModel) tblCodInter.getModel();
        String linea[] = leerTxt(ruta).split(";");
        int numLinea = 1;
        int op = 0, cArgs = 0, numReturn = 0;
        String linea2[];
        boolean bandera = false;
        ArrayList<String> argsF = new ArrayList<>();

        //ahora vamos a recorrer cada linea de codigo
        for (int i = 0; i < linea.length; i++) {
            linea2 = linea[i].split(" ");
            for (int j = 0; j < linea2.length; j++) {

                //verificamos asignaciones
                if (linea2[j].equals("=")) {
                    
                    for (int k = j + 1; k < linea2.length; k++) {
                                                
                        //verificamos si hay una coincidencia con estos operadores de primero
                        if (linea2[k].equals("*") || linea2[k].equals("/")) {
                            
                            tabla3.addRow(new Object[]{numLinea, "T1", linea2[k - 1], "="});
                            numLinea++;
                            tabla3.addRow(new Object[]{numLinea, "T1", linea2[k + 1], linea2[k]});
                            numLinea++;
                            bandera = true;
                            //break;
                        }

                        //despues verificamos si hay coincidencias con estos segundos ya que son de
                        //segunda prioridad
                        if (linea2[k].equals("+") || linea2[k].equals("-")) {
                            
                            tabla3.addRow(new Object[]{numLinea, "T1", linea2[k - 1], "="});
                            operadorAnterior.add(linea2[k - 1]);
                            numLinea++;
                            tabla3.addRow(new Object[]{numLinea, "T1", linea2[k + 1], linea2[k]});
                            numLinea++;
                            bandera = true;
                        }

                        if (linea2[k].equals("%")) {
                            tabla3.addRow(new Object[]{numLinea, "T1", linea2[k - 1], "="});
                            numLinea++;
                            tabla3.addRow(new Object[]{numLinea, "T1", linea2[k + 1], linea2[k]});
                            numLinea++;
                            bandera = true;
                            //break;
                        }
                        
                        if(argsF.contains(linea2[k])){
                            try{
                            if(linea2[k+1].equals("(") && linea2[k-1].equals("=")){
                                for(int u = k+1 ; u < linea2.length; u++){
                                    if(Global.containsKey(linea2[u])){
                                        tabla3.addRow(new Object[]{numLinea, "T1", linea2[u], "="});
                                        numLinea++;
                                        tabla3.addRow(new Object[]{numLinea, argsF.get(cArgs+1), "T1", "="});
                                        numLinea++;
                                        cArgs++;
                                    }
                                    
                                    if(linea2[u].equals(")")){
                                        tabla3.addRow(new Object[]{numLinea, "", op+1, "JMP"});
                                        numLinea++;
                                    }                                    
                                }
                                
                                for(int n = 0; n < linea.length; n++){
                                    linea2 = linea[n].split(" ");
                                    for(int m = 0; m < linea2.length; m++){
                                        if(linea2[m].equals("return") && linea2[m+1].matches(regexI)){
                                            tabla3.setValueAt(numLinea, numReturn-1, 2);
                                            tabla3.addRow(new Object[]{numLinea, "T1", linea2[m+1], "="});
                                            numLinea++;
                                        }
                                    }
                                }
                                
                            }
                            }catch(IndexOutOfBoundsException e){
                                
                            }
                        }

                    }

                    //se coloco una bandera para evitar duplicidad al momento de hacer la ultima asignacion
                    if (bandera == true) {
                        tabla3.addRow(new Object[]{numLinea, linea2[j - 1], "T1", linea2[j]});
                        numLinea++;
                    } else {
                        tabla3.addRow(new Object[]{numLinea, "T1", linea2[j + 1], "="});
                        numLinea++;
                        tabla3.addRow(new Object[]{numLinea, linea2[j - 1], "T1", linea2[j]});
                        numLinea++;
                    }
                }

                //esta linea de codigo es para verificar si hay una funcion o declaracion de una funcion
                try {
                    //verificamos si es una funcion si esta comple con las propiedades de una funcion
                    if (linea2[j].matches(regexI)) {
                        
                        if (linea2[j - 1].matches(regexT) && linea2[j + 1].equals("(")) {
                            op = numLinea;
                            tabla3.addRow(new Object[]{numLinea, "", "", "JMP"});
                            argsF.add(linea2[j]);
                            numLinea++;
                            for (int u = (j + 1) + 1; u < linea2.length; u++) {
                                if (linea2[u].equals(")")) {
                                    break;
                                } else {
                                    if (linea2[u].matches(regexI)) {
                                        argsF.add(linea2[u]);
                                    }
                                }
                            }
                        }
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    continue;
                }

                try{
                    if (linea2[j].equals("return")) {
                        tabla3.addRow(new Object[]{numLinea, "", "", "JMP"});
                        numReturn = numLinea;
                        numLinea++;
                        tabla3.setValueAt(numLinea, op - 1, 2);
                    }
                }catch(IndexOutOfBoundsException e){
                    
                }

            }

        }

    }
    
    //OPTIMIZADOR COMIENZA AQUI ----------
    public int contadorFunciones(String ruta){
        String linea[] = leerTxt(ruta).split(";");
        String linea2[];
        int numF = 0;
        for(int i = 0; i < linea.length; i++){
            linea2 = linea[i].split(" ");
            for(int k = 0; k < linea2.length; k++){
                
                //parte para saber si es una funcion
                try{
                    if (linea2[k - 1].matches(regexT) && linea2[k].matches(regexI) && linea2[k + 1].equals("(")) {
                        numF++;
                        nombreFuncio.add(linea2[k]);
                    }
                }catch(Exception e){
                    
                }
                
            }
        }
        
        return numF;
        
    }
        
    public void factorizacion(String ruta) throws IOException{
                
        int numFunciones = contadorFunciones(ruta);
        String linea[] = leerTxt(ruta).split(";");
        String linea2[], cadena = null, changeNameFuction = null;
        String linea3[], special = null;
        int numLineaBreak = 0, noperadoresF1 = 0, noperadoresF2 = 0, specialN = 0;
        int numLineBreak2 = 0;
        String opF1 = null, opF2 = null;
        boolean bandera = true, bandera2 = false;
        if(numFunciones > 1){
            
            //for para guardar el nombre de las funciones
            for(int i = 0; i < linea.length; i++){
                linea2 = linea[i].split(" ");
                for(int k = 0; k < linea2.length; k++){
                    
                    //try para saber si es una funcion por si hay errores
                    try{
                        //si este encuentra la forma de una fucion entrara aqui
                        if(linea2[k].matches(regexI) && linea2[k-1].matches(regexT) && linea2[k+1].equals("(")){
                            for(int n = i; n < linea.length; n++){
                                //System.out.println(linea[n]);
                                //terminara cuando encuentre el cierre de la funcion
                                if(linea[n].equals("}")){
                                    break;
                                }
                                
                                //una vez que sepa que es una funcino entonces procedera a recorrer solo la funcion
                                linea3 = linea[n].split(" ");
                                for(int b = 0; b < linea3.length; b++){
                                    //si cuando recorre la funcion encuentra otra funcion dentro 
                                    if((nombreFuncio.contains(linea3[b]) == true) && linea3[b-1].equals("=")){
                                        //System.out.println(linea2[k] + " " + linea3[b] + " " + linea3[b-1]);
                                        //banderaFuncion = false;
                                        special = linea2[k];
                                    }
                                    
                                }
                                
                            }
                        }
                    }catch(Exception e){
                        
                    }
                }
            }
            for(int i = 0; i < linea.length; i++){
                linea2 = linea[i].split(" ");
                
                for(int k = 0; k < linea2.length; k++){
                    try{
                        if(linea2[k].matches(regexI) && linea2[k-1].matches(regexT) && linea2[k+1].equals("(")){
                            bandera = false;
                            if(special.equals(linea2[k])){
                                for(int n = i; n < linea.length; n++){
                                    //System.out.println(linea[n]);
                                    if(linea[n].equals("}")){
                                        //linea para saber el final de la fucion
                                        numLineaBreak = n + 1;
                                        numLineBreak2 = numLineaBreak;
                                        //System.out.println("linea: " + numLineaBreak);
                                        break;
                                    }
                                    
                                    linea3 = linea[n].split(" ");
                                    for (int b = 0; b < linea3.length; b++) {
                                        //si cuando recorre la funcion encuentra otra funcion dentro 
                                        if(linea3[b].equals("+") || linea3[b].equals("-") || linea3[b].equals("*")
                                                || linea3[b].equals("/") || linea3[b].equals("%")){
                                            noperadoresF2++;
                                            opF2 = linea3[b];
                                        }

                                    }
                                    
                                }
                            }else{
                                
                                for(int n = i; n < linea.length; n++){
                                    //System.out.println(linea[n]);
                                    if(linea[n].equals("}")){
                                        //linea para saber el final de la fucion
                                        numLineaBreak = n + 1;
                                        break;
                                    }
                                    
                                    linea3 = linea[n].split(" ");
                                    for (int b = 0; b < linea3.length; b++) {
                                        //si cuando recorre la funcion encuentra otra funcion dentro 
                                        if(linea3[b].equals("+") || linea3[b].equals("-") || linea3[b].equals("*")
                                                || linea3[b].equals("/") || linea3[b].equals("%")){
                                            noperadoresF1++;
                                            opF1 = linea3[b];
                                        }

                                    }
                                    
                                }
                            }
                            
                        }
                    }catch(Exception e){
                        
                    }
                }
                
                if(bandera){
                    cadena = linea[i] + ";";
                    CadenaOptimizados.add(cadena);
                    System.out.println(cadena);
                }
                
            }
            
            for(int i = 0; i < linea.length; i++){
                linea2 = linea[i].split(" ");
                for(int k = 0; k < linea2.length; k++){
                    try{
                        if(linea2[k].matches(regexI) && linea2[k-1].matches(regexT) && linea2[k+1].equals("(")){
                            
                            if(special.equals(linea2[k]) && (noperadoresF2 > noperadoresF1)){
                                for(int n = i; n < linea.length; n++){
                                    
                                    if(linea[n].equals("}")){
                                        //linea para saber el final de la fucion
                                        numLineaBreak = n + 1;
                                        //System.out.println("linea: " + numLineaBreak);
                                        System.out.println("} ;");
                                        CadenaOptimizados.add("} ;");
                                        break;
                                    }
                                    
                                    linea3 = linea[n].split(" ");
                                    for (int b = 0; b < linea3.length; b++) {
                                        
                                        if ((nombreFuncio.contains(linea3[b]) == true) && linea3[b - 1].equals("=")) {
                                            specialN = n;
                                            for(int d = 0; d < linea3.length; d++){
                                                if(nombreFuncio.contains(linea3[d]) || linea3[d].equals("(") || linea3[d].equals(")")){
                                                    
                                                }else if(linea3[d].equals(",")){
                                                    System.out.print(opF1);
                                                    cadena += opF1;
                                                }else{
                                                    if(d == 0){
                                                        System.out.print(linea3[d]);
                                                        cadena += linea3[d];
                                                    }else{
                                                        System.out.print(" " + linea3[d] + " ");
                                                        cadena = cadena + " " + linea3[d] + " ";
                                                    }
                                                }
                                                                                                
                                                if (d == (linea3.length - 1)) {
                                                    System.out.print(";\n");
                                                    cadena += ";\n";
                                                    CadenaOptimizados.add(cadena);
                                                }
                                            }
                                        }
                                                                                
                                    }
                                    
                                    if(n == specialN){
                                        continue;
                                    }else{
                                        cadena = linea[n] + ";";
                                        System.out.println(cadena);
                                        CadenaOptimizados.add(cadena);
                                    }
                                                                        
                                }
                            }else if(!special.equals(linea2[k]) && (noperadoresF2 < noperadoresF1)){
                                bandera2 = true;
                                changeNameFuction = linea2[k];
                                for(int n = i; i < linea.length; n++){
                                    System.out.println(linea[n] + ";");
                                    cadena = linea[n] + ";";
                                    if(linea[n].equals("}")){
                                        numLineaBreak = n + 1;
                                        break;
                                    }
                                    CadenaOptimizados.add(cadena);
                                }
                            }
                            
                        }
                    }catch(Exception e){
                        
                    }
                }
            }
            
            if(bandera2){
                String subLinea[];
                for(int n = numLineBreak2; n < linea.length; n++){
                    subLinea = linea[n].split(" ");
                    cadena = "";
                    for(int x = 0; x < subLinea.length; x++){
                        if(special.equals(subLinea[x])){
                            //System.out.print(changeNameFuction + " ");
                            cadena += changeNameFuction + " ";
                        }else{
                            if(x == (subLinea.length - 1)){
                                //System.out.print(subLinea[x] + " ;\n");
                                cadena += subLinea[x] + ";";
                            }else{
                                //System.out.print(subLinea[x] + " ");
                                cadena += subLinea[x] + " ";
                            }
                        }
                    }
                    System.out.println(cadena);
                    CadenaOptimizados.add(cadena);
                }
            }else{
                for (int i = numLineaBreak; i < linea.length; i++) {
                    System.out.println(linea[i] + ";");
                    cadena = linea[i] + ";";
                    CadenaOptimizados.add(cadena);
                }
            }
            
            
            
        }else{
            System.out.println("Solo se encontro una funcion");
            for(int i = 0; i < linea.length; i++){
                CadenaOptimizados.add(linea[i] + ";");
            }
        }
        
        System.out.println("----------");
        for(String lkn : CadenaOptimizados){
            System.out.println(lkn);
        }
        
        FileWriter myWriter = new FileWriter("C:\\Users\\kreed\\Documents\\aaaaaa\\archivoOptimizado\\CodigOpti.txt");
        for(String cadenaLista : CadenaOptimizados){
            myWriter.write(cadenaLista + "\n");
        }
        JOptionPane.showMessageDialog(this, "ANALIZIS COMPLETADO","AVISO", JOptionPane.INFORMATION_MESSAGE);
        
        myWriter.close();
        
    }
    
    //GENERADOR DEL CODIGO ENSAMBLADOR
    public void generadorEnsamblador(){
        String lineaFinal = "", cO="", cF="", oP = "", opA = "";
        DefaultTableModel tabla = (DefaultTableModel) tblCodInter.getModel();
        int fila = tabla.getRowCount(), contadorJMP = 0;
        int columna = tabla.getColumnCount();
        boolean banderaOperador = false;
        System.out.println("\n\n-----[E N S A M B L A D O R] -----\n\n");
        for(int i = 0; i < fila ; i++){
            
            for(int k = 1; k < columna; k++){
                if(k == 1){
                    cO = tabla.getValueAt(i, k).toString();
                }
                if(k == 2){
                    cF = tabla.getValueAt(i, k).toString();
                }
                if(k==3){
                    oP = tabla.getValueAt(i, k).toString();
                }
            }
            
            //ASIGNACION OP-1
            if (oP.equals("=") && cO.equals("T1")) {
                lineaFinal = "MOV AX," + cF +";";
            }
            if(banderaOperador){
                //ASIGNACION OP-3
                System.out.println("---ENTRO AQUII----");
                if(opA.equals("/")){
                    lineaFinal = "MOV " + cO + ", AL;";
                }else if(opA.equals("%")){
                    lineaFinal = "MOV " + cO + ", AH;";
                }
                banderaOperador = false;
            }else{
                //ASIGNACION OP-2
                System.out.println("---[SALIDA NO TERMINADA]----");
                if (oP.equals("=") && !cO.equals("T1")) {
                    lineaFinal = "MOV " + cO + ", AX;";
                }
            }
            
            //MODULACION O PORCENTAJE
            if(oP.equals("%")){
                lineaFinal = "MOV ";
                if(cO.equals("T1")){
                    lineaFinal += "BL, " + cF +";";
                    lineaFinal += "\nDIV BL;";
                }
                banderaOperador = true;
                opA = oP;
            }
            
            //MULTIPLICAR
            if(oP.equals("*")){
                lineaFinal = "MOV ";
                if(cO.equals("T1")){
                    lineaFinal += "BL, " + cF +";";
                    lineaFinal += "\nMUL BL;";
                }
                
            }
            
            //DIVISION
            if(oP.equals("/")){
                lineaFinal = "MOV ";
                if(cO.equals("T1")){
                    lineaFinal += "BL, " + cF +";";
                    lineaFinal += "\nDIV BL;";
                }
                banderaOperador = true;
                opA = oP;
            }
            
            //SUMATORIA
            if(oP.equals("+")){
                lineaFinal = "ADD ";
                if(cO.equals("T1")){
                    lineaFinal += "AX, " + cF +";";
                }
            }
            
            //RESTA
            if(oP.equals("-")){
                lineaFinal = "SUB ";
                if(cO.equals("T1")){
                    lineaFinal += "AX, " + cF +";";
                }
            }
            
            //FUNCION
            if(oP.equals("JMP")){
                if(contadorJMP == 0){
                    //inicio de funcion
                    lineaFinal ="\n"+ oP + " ASIGNA_PARAMETROS\n[INICIO]:";
                    txtAreaEnsamblador.setForeground(Color.BLUE);
                    contadorJMP++;
                }else if(contadorJMP == 1){
                    lineaFinal = "\n" + oP + " VALOR_A_RETORNAR;\n\nASIGNA_PARAMETROS:";
                    contadorJMP++;
                }else if(contadorJMP > 1){
                    lineaFinal = "\n" + oP + " [INICIO]; \n\nVALOR_A_RETORNAR:";
                }
            }
            
            System.out.println(lineaFinal);
            txtAreaEnsamblador.append(lineaFinal + "\n");
        }        
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel Panel;
    private javax.swing.JButton btnAnalizar;
    private javax.swing.JButton btnAnalizarOptimizado;
    private javax.swing.JButton btnArchivo;
    private javax.swing.JButton btnBuscar2;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JScrollPane jScrollPane5;
    private javax.swing.JScrollPane jScrollPane7;
    private javax.swing.JLabel lblOptimizado;
    private javax.swing.JLabel lblOriginal;
    private javax.swing.JLabel lblTitulo;
    private javax.swing.JLabel lblTitulo2;
    private javax.swing.JLabel lblTituloProyecto;
    private javax.swing.JLabel lblTituloTablaEnsamblador;
    private javax.swing.JTable tblCodInter;
    private javax.swing.JTable tblErrores;
    private javax.swing.JTable tblSimbolos;
    private javax.swing.JTextArea txtAreaCodigo;
    private javax.swing.JTextArea txtAreaEnsamblador;
    private javax.swing.JTextArea txtAreaOptmizado;
    // End of variables declaration//GEN-END:variables
}
